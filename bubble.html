<!DOCTYPE html>
<meta charset="utf-8">
<style>

text {
	font: 10px arial;
}

.a {
	/* fill: #1F77B4; */
	fill: #CCCCCC;
}

.b {
	/* fill: #FF7F0E; */
	fill: #CCCCCC;
}

.c {
	/* fill: #2CA02C; */
	fill: #CCCCCC;
}

.d {
	/* fill: #D62728; */
	fill: #CCCCCC;
}

.e {
	/* fill: #9467BD; */
	fill: #CCCCCC;
}

.f {
	/* fill: #8C564B; */
	fill: #CCCCCC;
}

.legend {
	padding: 5px;
	font: 10px sans-serif;
	background: yellow;
	box-shadow: 2px 2px 1px #888;
}

</style>
<body>
	<div align='center'>
	<button type="button" onclick="renderAll()" style="font-size:15px">All</button>
	<button type="button" onclick="renderByGender()" style="font-size:15px">By Gender</button>
	<button type="button" onclick = "renderByGroup2()" style="font-size:15px">By Group3</button>
	</div>
</body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

d3.selection.prototype.moveToFront = function() {
  return this.each(function(){
    this.parentNode.appendChild(this);
  });
};

var diameter = 485,
		format = d3.format(",d"),
		all_nodes,
		a_nodes,
		b_nodes,
		c_nodes,
		d_nodes,
		e_nodes,
		f_nodes,
		split_nodes = [];

var bubble_all = d3.layout.pack()
		.sort(null)
		.size([485, 485])
		.padding(1.5);

var bubble = d3.layout.pack()
		.sort(null)
		.size([diameter, diameter])
		.padding(1.5);

var svg = d3.select("body").append("svg")
		.attr("width", 2000)
		.attr("height", 2000)
		.attr("class", "bubble");

d3.json("most_informative_features_new.json", function(error, json) {
	if (error) throw error;

	var as = [],
			bs = [],
			cs = [],
			ds = [],
			es = [],
			fs = [];

	var as2 = [],
			bs2 = [],
			cs2 = [],
			ds2 = [],
			es2 = [],
			fs2 = [];

	for(i=0; i<json.length; i++) {
		switch(json[i].gender) {
			case 'a':
				as.push(json[i]);
				break;
			case 'b':
				bs.push(json[i]);
				break;
			case 'c':
				cs.push(json[i]);
				break;
			case 'd':
				ds.push(json[i]);
				break;
			case 'e':
				es.push(json[i]);
				break;
			default:
				fs.push(json[i]);
				break;
		}
		switch(json[i].group2) {
			case 'a':
				as2.push(json[i]);
				break;
			case 'b':
				bs2.push(json[i]);
				break;
			case 'c':
				cs2.push(json[i]);
				break;
			case 'd':
				ds2.push(json[i]);
				break;
			case 'e':
				es2.push(json[i]);
				break;
			default:
				fs2.push(json[i]);
				break;
		}
	}

	all_nodes = {
		text: "root",
		children: json
	}

	a_nodes = {
		text: "root",
		children: as
	}

	b_nodes = {
		text: "root",
		children: bs
	}

	c_nodes = {
		text: "root",
		children: cs
	}

	d_nodes = {
		text: "root",
		children: ds
	}

	e_nodes = {
		text: "root",
		children: es
	}

	f_nodes = {
		text: "root",
		children: fs
	}

	a_nodes2 = {
		text: "root",
		children: as2
	}

	b_nodes2 = {
		text: "root",
		children: bs2
	}

	c_nodes2 = {
		text: "root",
		children: cs2
	}

	d_nodes2 = {
		text: "root",
		children: ds2
	}

	e_nodes2 = {
		text: "root",
		children: es2
	}

	f_nodes2 = {
		text: "root",
		children: fs2
	}

	all_nodes = bubble_all.nodes(classes(all_nodes));
	a_nodes = bubble.nodes(classes(a_nodes));
	b_nodes = bubble.nodes(classes(b_nodes));
	c_nodes = bubble.nodes(classes(c_nodes));
	d_nodes = bubble.nodes(classes(d_nodes));
	e_nodes = bubble.nodes(classes(e_nodes));
	f_nodes = bubble.nodes(classes(f_nodes));

	a_nodes2 = bubble.nodes(classes(a_nodes2));
	b_nodes2 = bubble.nodes(classes(b_nodes2));
	c_nodes2 = bubble.nodes(classes(c_nodes2));
	d_nodes2 = bubble.nodes(classes(d_nodes2));
	e_nodes2 = bubble.nodes(classes(e_nodes2));
	f_nodes2 = bubble.nodes(classes(f_nodes2));

	//Remove root
	all_nodes.splice(0,1);
	a_nodes.splice(0, 1);
	b_nodes.splice(0, 1);
	c_nodes.splice(0, 1);
	d_nodes.splice(0, 1);
	e_nodes.splice(0, 1);
	f_nodes.splice(0, 1);

	a_nodes2.splice(0, 1);
	b_nodes2.splice(0, 1);
	c_nodes2.splice(0, 1);
	d_nodes2.splice(0, 1);
	e_nodes2.splice(0, 1);
	f_nodes2.splice(0, 1);

	split_nodes = a_nodes.slice();
	for(i=0; i < b_nodes.length; i++) {
		split_nodes.push(b_nodes[i]);
	}
	for(i=0; i < c_nodes.length; i++) {
		split_nodes.push(c_nodes[i]);
	}
	for(i=0; i < d_nodes.length; i++) {
		split_nodes.push(d_nodes[i]);
	}
	for(i=0; i < e_nodes.length; i++) {
		split_nodes.push(e_nodes[i]);
	}
	for(i=0; i < f_nodes.length; i++) {
		split_nodes.push(f_nodes[i]);
	}

	split_nodes2 = a_nodes2.slice();
	for(i=0; i < b_nodes2.length; i++) {
		split_nodes2.push(b_nodes2[i]);
	}
	for(i=0; i < c_nodes2.length; i++) {
		split_nodes2.push(c_nodes2[i]);
	}
	for(i=0; i < d_nodes2.length; i++) {
		split_nodes2.push(d_nodes2[i]);
	}
	for(i=0; i < e_nodes2.length; i++) {
		split_nodes2.push(e_nodes2[i]);
	}
	for(i=0; i < f_nodes2.length; i++) {
		split_nodes2.push(f_nodes2[i]);
	}

	update(all_nodes, 'all');
	addLegend();
});

// Returns a flattened hierarchy containing all leaf nodes under the root.
function classes(root) {
	var classes = [];

	function recurse(name, node) {
		if (node.children) node.children.forEach(function(child) { recurse(node.text, child); });
		else classes.push({packageName: node.gender, packageName2: node.group2, className: node.text, value: node.size});		// Use value for node.size ?????
	}

	recurse(null, root);
	return {children: classes};
}

function mouseover() {
	var sel = d3.select(this);
	if (d3.event.shiftKey) {
		if (sel.attr("isbig") == 0) {
			sel.select("circle")
				.attr("stroke-width", 8);
			sel.attr("isbig", 1);
			sel.select("text")
				.text(function(d) { return d.className; });
		}
	}

  sel.attr("originalr", function(d) { return d.r; })
		.moveToFront()
		// .attr("oldr", d3.select(this).select("circle").attr("r"))
		.select("circle").transition()
      .duration(50)
      .attr("r", 50)
	sel.select("text")
			.text(function(d) { return d.className; });
}

function mouseout() {
	var sel = d3.select(this);
	if (d3.event.ctrlKey) {
		if (sel.attr("isbig") == 1) {
			sel.select("circle")
				.attr("stroke-width", 0);
			sel.attr("isbig", 0);
			sel.select("text")
				.text(function(d) { return d.className.substring(0, d.r / 3); });
			}
	}

	sel.select("circle").transition()
      .duration(50)
      .attr("r", sel.attr("originalr"));
	if (sel.attr("isbig") == 1) return;
	sel.select("text")
		.text(function(d) { return d.className.substring(0, d.r / 3); });
}

function click() {
	// console.log(svg.selectAll(".node")[0][1]);
	// for (el in svg.selectAll(".node")) {
	// 	console.log(el);
	// }
	// if (d3.event.shiftKey) {
	// 	var nodeClass = d3.select(this).select("circle").attr("class");
	// 	d3.json("most_informative_features_new.json", function(error, json) {
	// 		for (i=0; i<json.length; i++) {
	// 			console.log(json[i]);
	// 			if (nodeClass == json[i].gender) {
	// 				var sel = d3.select(json[i]);
	// 				if (sel.select("circle").attr("isbig") == 0) {
	// 					// mouseover;
	// 					sel.select("circle")
	// 						.attr("stroke-width", 8);
	// 					sel.attr("isbig", 1);
	// 					sel.select("text")
	// 						.text(function(d) { return d.className; });
	// 				} else {
	// 					// mouseout;
	// 					sel.select("circle")
	// 						.attr("stroke-width", 0);
	// 					sel.attr("isbig", 0);
	// 					sel.select("text")
	// 						.text(function(d) { return d.className.substring(0, d.r / 3); });
	// 			}
	// 		}
	// 	}
	// })
	// 	return;
	// }

	var sel = d3.select(this);
	if (sel.attr("isbig") == 0) {
		// mouseover;
		sel.select("circle")
			.attr("stroke-width", 8);
		sel.attr("isbig", 1);
		sel.select("text")
			.text(function(d) { return d.className; });
	} else {
		// mouseout;
		sel.select("circle")
			.attr("stroke-width", 0);
		sel.attr("isbig", 0);
		sel.select("text")
			.text(function(d) { return d.className.substring(0, d.r / 3); });
	}
}

function update(nodes, mode) {

	var node = svg.selectAll(".node")
			.data(nodes, function(d) { return d.className; })
			.on("mouseover", mouseover)
			.on("mouseout", mouseout)
			.on("click", click);

	node.transition()
			.duration(750)
			.attr("transform", function(d) {
				if (mode == 'all') {
					return "translate(" + (d.x + 1000) + "," + (d.y + 1000) + ")";
				} else {
					var realPackage = ((mode == 'split') ? d.packageName : d.packageName2);
					switch (realPackage) {
						case 'a':
							return "translate(" + (d.x + 750) + "," + (d.y + 500) + ")";
						case 'b':
							return "translate(" + (d.x + 1250) + "," + (d.y + 500) + ")";
						case 'c':
							return "translate(" + (d.x + 1500) + "," + (d.y + 1000) + ")";
						case 'd':
							return "translate(" + (d.x + 1250) + "," + (d.y + 1500) + ")";
						case 'e':
							return "translate(" + (d.x + 750) + "," + (d.y + 1500) + ")";
						default:
							return "translate(" + (d.x + 500) + "," + (d.y + 1000) + ")";
					}
				}

			});

	node.select('circle')
		.transition()
		.duration(750)
		.attr("r", function(d) { return d.r; })

	//INSERT
	var news = node.enter().append("g")
			.attr("class", function(d) { return "node"; })
			// .attr("originalr", function(d) { return d.r; })
			.attr("isbig", function(d) { return 0; })
			.attr("transform", function(d) { return "translate(" + (d.x + 1000) + "," + (d.y + 1000) + ")"; });

	news.append("title")
			.text(function(d) { return d.className + ": " + d.value; });

	news.append("circle")
			.attr("r", function(d) { return d.r; })
			.attr("stroke", 'red')
			.attr("stroke-width", 0)
			.attr("class", function(d) { return ((mode == 'switch') ? d.packageName : d.packageName2); });

	news.append("text")
			.attr("dy", ".3em")
			.style("text-anchor", "middle")
			.text(function(d) { return d.className.substring(0, d.r / 3); });


	//REMOVE
	node.exit().remove();

}

function renderByGroup2() {
	update(split_nodes2, 'split2');
}

function renderByGender() {
 	update(split_nodes, 'split');
}

function renderAll() {
 	update(all_nodes, 'all');
}

function addLegend() {
	var legend = svg.append("g")
	  .attr("class", "legend")
	  .attr("x", 0)
	  .attr("y", 25)
	  .attr("height", 100)
	  .attr("width", 100);

	legend.append("rect")
          .attr("x", 2)
          .attr("y", 25)
          .attr("width", 20)
          .attr("height", 20)
          .style("fill", '#fc8d59');

    legend.append("text")
          .attr("x", 27)
          .attr("y", 35)
          .attr("height",30)
          .attr("width",100)
          .style("fill", '#fc8d59')
          .text('Female');

	legend.append("rect")
          .attr("x", 2)
          .attr("y", 50)
          .attr("width", 20)
          .attr("height", 20)
          .style("fill", '#91bfdb');

    legend.append("text")
          .attr("x", 27)
          .attr("y", 60)
          .attr("height",30)
          .attr("width",100)
          .style("fill", '#91bfdb')
          .text('Male');

}

d3.select(self.frameElement).style("height", diameter + "px");

</script>
